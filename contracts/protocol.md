# API Contract Protocol

## Overview

API contracts define explicit interfaces between phases. They enable early detection of integration errors by validating that what one phase produces matches what subsequent phases expect.

## Directory Structure

```
.planning/phases/XX-name/
├── PLAN.md
├── SUMMARY.md
└── CONTRACTS/
    ├── exports.ts          # Types this phase exports
    ├── dependencies.ts     # Types this phase requires
    └── README.md           # Contract documentation
```

## Contract Generation

### During Planning (`/gsd:plan-phase`)

When planner identifies cross-phase dependencies:

1. **Identify Exports**
```typescript
// .planning/phases/01-foundation/CONTRACTS/exports.ts

// User model and types exported by Phase 01
export interface User {
  id: string;
  email: string;
  passwordHash: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface UserCreate {
  email: string;
  password: string;
}

export interface UserResponse {
  id: string;
  email: string;
  createdAt: Date;
}

// API contract
export interface UserAPI {
  'POST /api/users': {
    request: UserCreate;
    response: UserResponse;
  };
  'GET /api/users/:id': {
    params: { id: string };
    response: UserResponse;
  };
}
```

2. **Identify Dependencies**
```typescript
// .planning/phases/02-auth/CONTRACTS/dependencies.ts

// What Phase 02 needs from Phase 01
import type { User, UserResponse, UserAPI } from '../../01-foundation/CONTRACTS/exports';

// Re-export to document dependency
export type { User, UserResponse, UserAPI };

// Phase 02's own requirements
export interface AuthDependencies {
  userRepository: {
    findByEmail(email: string): Promise<User | null>;
    findById(id: string): Promise<User | null>;
  };
}
```

## Contract Validation

### During Execution (`/gsd:execute-phase`)

After each task, verify contracts:

```typescript
// Contract validation pseudo-code
async function validateContracts(phase: string) {
  const exports = loadContracts(`${phase}/CONTRACTS/exports.ts`);

  for (const [name, type] of Object.entries(exports)) {
    // Check file exists
    const implementation = findImplementation(name);
    if (!implementation) {
      return { valid: false, error: `Missing implementation for ${name}` };
    }

    // Check type compatibility (via TypeScript compiler API)
    const compatible = checkTypeCompatibility(implementation, type);
    if (!compatible) {
      return { valid: false, error: `Type mismatch for ${name}` };
    }
  }

  return { valid: true };
}
```

### During Integration Check (`/gsd:audit-milestone`)

Validate all phase contracts:

```bash
# Check each phase's dependencies are satisfied
for phase_dir in .planning/phases/*/; do
  if [[ -d "${phase_dir}CONTRACTS" ]]; then
    # Check dependencies.ts imports resolve
    # Check exports.ts types exist in codebase
    # Report any mismatches
  fi
done
```

## Contract Schema

### exports.ts Template

```typescript
/**
 * Phase: {phase_name}
 * Generated by: /gsd:plan-phase
 *
 * This file defines what this phase provides to subsequent phases.
 * DO NOT manually edit - regenerate with /gsd:plan-phase --contracts
 */

// Domain Models
export interface {ModelName} {
  // fields...
}

// DTOs
export interface {ModelName}Create {
  // fields...
}

export interface {ModelName}Response {
  // fields...
}

// API Contracts
export interface {Resource}API {
  '{METHOD} {path}': {
    request?: RequestType;
    params?: ParamsType;
    response: ResponseType;
    errors?: ErrorType[];
  };
}

// Service Contracts
export interface {ServiceName} {
  methodName(params: ParamsType): Promise<ReturnType>;
}
```

### dependencies.ts Template

```typescript
/**
 * Phase: {phase_name}
 * Dependencies from previous phases
 */

// Import from phase 01
import type {
  User,
  UserCreate,
  UserResponse
} from '../../01-foundation/CONTRACTS/exports';

// Re-export for documentation
export type { User, UserCreate, UserResponse };

// Additional runtime dependencies
export interface {Phase}Dependencies {
  // What this phase needs at runtime
}
```

## Integration with must_haves

Contracts enhance the must_haves verification:

```yaml
must_haves:
  truths:
    - "User can create account"
  artifacts:
    - path: "src/models/user.ts"
      provides: "User model"
      contract: ".planning/phases/01-foundation/CONTRACTS/exports.ts#User"
  key_links:
    - from: "src/api/users.ts"
      to: "src/models/user.ts"
      via: "import"
      contract_validation: true
```

## Commands

- `/gsd:contracts` - Show all phase contracts
- `/gsd:contracts validate` - Validate all contracts against codebase
- `/gsd:contracts generate` - Regenerate contracts from SUMMARY.md

## Benefits

1. **Early Error Detection**: Catch integration issues before execution
2. **Clear Boundaries**: Explicit interfaces between phases
3. **Type Safety**: TypeScript types for compile-time checking
4. **Documentation**: Contracts serve as API documentation
5. **Refactoring Safety**: Know what depends on what
